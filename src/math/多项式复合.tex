\paragraph{问题} 给出两个最高次数均为 $x^n$ 的多项式 $F(x)$ 和 $G(x)$，求 $F(G(x))$ 的 $0 \dots n$ 项系数。

首先要注意形式幂级数的复合只有在 $G(x)$ 没有常数项时才是良定义的，不然 $F(G(0))$ 不一定收敛。不过如果只是多项式复合就无所谓了。

\paragraph{做法} 设 $H(x) = F(G(x))$，也就是

$$ H(x) = \sum_{i = 0} ^ n f_i G(x) ^ i $$

点积是不好做的，不过可以把 $F(x)$ 的系数反过来变成卷积。设 $r_i = f_{n - i}$，那么

$$ \begin{aligned}
H(x) \equiv & \sum_{i = 0} ^ n r_{n - i} G(x) ^ i \\
\equiv & \sum_{i = 0} ^ n r_{n - i} \left[ y ^ i \right] \frac 1 {1 - y G(x)} \\
\equiv & \left[ y ^ n \right] \frac {R(y)} {1 - y G(x)} \pmod {x ^ {n + 1}}
\end{aligned} $$

发现这个形式和多项式复合逆的子问题很像，不过这里要求的是 $y^n$ 项的系数。仍然按照 Bostan-Mori 算法的思路，上下同乘 $Q(-x, y)$：

$$ \begin{aligned}
\left[ y ^ n \right] \frac {R(y)} {Q(x, y)} \equiv & \left[ y ^ n \right] \frac {R(y)} {Q(x, y) Q(-x, y)} Q(-x, y) \\
\equiv & \left[ y ^ n \right] \frac {R(y)} {V(x ^ 2, y)} Q(-x, y) \pmod {x ^ {n + 1}}
\end{aligned} $$

那么 $\frac {R(y)} {V(x ^ 2, y)} \pmod {x ^ {n + 1}}$ 就变成了一个 $x$ 的最高次数减半的子问题，这时后面的 $\pmod {x ^ {n + 1}}$ 就用得上了。因为乘了一次所以 $y$ 的最高次数会翻倍，一直递归到底才会达到 $y^n$。注意递归的时候 $R(y)$ 是完全不变的，因此为了保证复杂度需要先递归地做下去，返回的时候再乘 $Q(-x, y)$。边界是 $\frac {R(y)} {Q(x, y)} \equiv R(y) Q(0, y) ^ {-1} \pmod {x ^ 1}$。

返回的时候 $x$ 的最高次数要翻一倍，不需要处理，最多把超过当前层 $n$ 的部分截掉就行了。而因为我们最终只需要 $y^n$ 项，假设当前 $Q(-x, y)$ 的 $y$ 次数是 $2^k$，那么当前层返回的结果的 $y^i$ 项最多会影响到最终的第 $i + 1 + 2 + 4 + \dots + 2^{k - 1} = i + 2^k - 1$ 项，因此每层只需要返回最高的 $2^k$ 项。每层的总项数都是 $O(n)$ 的，总复杂度是 $O(n \log^2 n)$。

类似多项式复合逆，这里也有一个优化：在递归的时候 $y$ 的最高次数是 $2^k$，项数就是 $2^k + 1$，做卷积的时候会多做一倍。但可以注意到 $Q(x, y)$ 的 $y_0$ 项始终是 $1$，所以可以把它提出来，这样项数就刚好是 $2^k$ 了，每步按照 $(Ay + 1) (By + 1) = (ABy + A + B) y + 1$ 计算即可。

这样优化的话，返回时会变成取一个 $2^{k + 1}$ 项多项式与一个 $2^k$ 项多项式的乘积的较高 $2^k$ 项。实际上按照循环卷积的原理，直接做长为 $2^{k + 1}$ 的 FFT 就行了，这时较高的 $2^k$ 项在循环卷积下是不受影响的。

另外因为返回时还涉及到 $\frac {R(y)} {V(x ^ 2, y)}$ 的 FFT，因为 FFT 本质就是单位根处的点值，所以可以发现 $x$ 这一维的 DFT 实际上就是 $\frac {R(y)} {V(x, y)}$ 的 DFT 再重复一次。这样返回时可以少做一半 FFT，减少一些常数。

代码里的 \mintinline{cpp}|dft_2d| 和 \mintinline{cpp}|idft_2d| 和多项式复合逆里的是一样的，去抄一下就行了。

\inputminted{cpp}{../src/math/多项式复合.cpp}
